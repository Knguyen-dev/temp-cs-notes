# OWASP: File Upload

Some applications need the user to uplaod a file. We need to be able to fend off malicious files to keep the app and the users safe. Here are the guidelines:
- List allowed file extensions.
- Have input validation for the fil. Don't trust `Content-Type` header since it can be spoofed (faked).
- Change the filename to something that's generated by the application. This generally avoids stuff like directory traversal attacks and like trying to have a long name to slow down the app, or something similar. If you are letting the user name their file make sure it has a filename length limit, and restrict allowed characters to prevent directory traversal.
- Set a size limit for the file as well.
- If possible, we want to store the files on a different server from where the main services are. If this isn't possible store the files outside of the webroot. Remember the webroot is just the root directory of our webserver, so we're just saying in any case it's ideal we don't store it inside the directory that the app is running.
- In some situations, we want to run the file through an antivirus or a sandbox to validate that it doesn't contain malicious data. Or run the file through **CDR (Content Disarm and Reconstruct)** if applicable. CDR is cybersecurity tech which strips away potentially malicious data in a file, retaining the good parts.
- Protect the file upload from CSRF.

### File Upload: Threats
- **Malicious files:** Here are some issues that can arise due to file uploading. Common ones are ZIP or XML bombs, which are hueg files that are used to fill the server storage and hinder the server's availability. You can have other things like a file that attempts to traverse the application file system (using funny name) and overwrite certain files.
- **Public File Retrevial:** In the case where the file can be publicly retrievable by other users, there are other threats. Things such as taking care of issues where users can see the files of other users. Or maybe in a DoS attack where they request a lot of files. Or the file content could be illegal, offensive or dangerous.

### File Upload: Protecting against extensions and filenames
- Extension validation: on the server side. Also make sure to have an allow-list of file extensions that we want. 
- Content-Type header: This header cannot be trusted as it is simple to proof. While not secure, it is a quick check against simple attacks. You can check the MIME-type of the which is more secure. Use an allowlist or denylist approach.
- File Signature: Check the file's signature against the signature of the expected file we want.
- Filename safety: Define max length, restrict the characters in the filename and content. Users may add stuff like "." or ".." for creating hidden files or do directory traversal. Don't use leading hypen or spaces to be it easier for shell files to process it.

### File Upload: Protecting File Content
Based on the file type, we can do different things:
- Images: Use image rewriting techniques that destroys malicious content within an image. It's actually possible for attackers ot hide malicious scripts or data niside the pixels of an image. Polyglot files are files that are valid images, and valid scripts. The headers of an image could be used to raise exceptions in image processing libraries. Image rewriting techniques are typically used in services like Cloudinary and CDNs like Cloudflare. Anyways after applying image rewriting, just set the exteension to be what we detect based on the file contents. If the extension we find isn't in the allowlist, you may want to stop.
- ZIP files: They can contain all types of files and the attack vectors are many. Before unzipping it, check the target path, level of compression, and estimated unzip size. Then I guess recursively check each file for bad stuff.

### File Upload: Storing Files
Obviously you should balance business logic and security:
- Store the files on a different server, which separates the duties between teh application serving the user and the application handling file uploads and storing those files.
- Store the files outsidethe webroot, only allowing admin access. You could also store them inside but only set them to write perms only. Apparently this makes sure the user won't be able to download it and ultimately read it.
- You should also make upload limits, meaning if a file is too big, we won't store it. Also let's say our app is rendering the contents of a file, if fiel is too big, we probably can't render or send all the network over the network.


## Credits
- [File Uploads - OWASP](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)